#!/usr/bin/env python

'''Entry point to the music server.'''

import argparse
import collections
import json
import logging
import os
import signal
import sys

import tornado.httpclient
import tornado.web

__author__ = 'Antonio Serrano Hernandez'
__copyright__ = 'Copyright 2021'
__license__ = 'proprietary'
__version__ = '0.1'
__maintainer__ = 'Antonio Serrano Hernandez'
__email__ = 'toni.serranoh@gmail.com'
__status__ = 'Development'
__script__ = 'music-server'

############################### Daemon Utilities ##############################

def _daemonize():
    '''Daemonize the current process.'''
    # Clear file creation mask
    os.umask(0)

    # Become a session leader to lose controlling TTY
    if os.fork() != 0:
        # parent
        sys.exit(0)

    # Ensure future opens won't allocate controlling TTYs
    signal.signal(signal.SIGHUP, signal.SIG_IGN)
    if os.fork() != 0:
        # parent
        sys.exit(0)

    # Change the current working directory to the root so we won't
    # prevent file systems from being unmounted
    os.chdir('/')

    # Close all open file descriptors
    for i in range(1024):
        try:
            os.close(i)
        except OSError:
            pass

    # Attach file descriptors 0, 1 and 2 to /dev/null
    os.open('/dev/null', os.O_RDWR)
    os.dup(0)
    os.dup(0)

class Daemon:
    '''A daemon process.

    The daemon is implemented with a context manager. When the context manager
    is entered, the daemon is created (process detached from controlling
    terminal, term signal managed and pidfile created. At exit, the pidfile is
    removed to inform the service manager that this service is finished.

    Example of use:

    d = Daemon(app, True, '/var/run/myapp.pid')
    with d:
        # Do stuff with app
        app.run()
    '''

    def __init__(self, app, daemonize=True, pidfile=None):
        '''Create the daemon.

        * daemonize: if True, daemonize this process.
        * pidfile: if given, the name of the file that will contain the PID of
            the daemonized process.
        '''
        self._app = app
        self._do_daemonize = daemonize
        self._pidfile = pidfile

    def __enter__(self):
        '''Enter the daemon.

        The process is daemonized.
        '''
        # Daemonize the process, if demanded
        if self._do_daemonize:
            _daemonize()

        # Write the pidfile
        if self._pidfile is not None:
            with open(self._pidfile, 'w') as file_:
                file_.write(f'{os.getpid()}')

        # Set the term signal
        signal.signal(signal.SIGINT, self._term)
        signal.signal(signal.SIGTERM, self._term)

        return self

    def _term(self, *args):
        '''TERM signal received.

        Signal the app that it must stop.
        '''
        # Stop the application
        self._app.stop()

    def __exit__(self, exc_type, exc_value, traceback):
        '''Stop this daemon.'''
        # Remove the pid file
        if self._pidfile is not None:
            try:
                os.unlink(self._pidfile)
            except OSError:
                logging.warning('cannot remove pidfile %s', self._pidfile)

################################ Web interface ################################

class BaseHandler(tornado.web.RequestHandler):

    def initialize(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

class WebServer:

    def __init__(self, handlers, port=8888, **kwargs):
        tornado.httpclient.AsyncHTTPClient.configure(
            'tornado.curl_httpclient.CurlAsyncHTTPClient')
        self._port = port
        self._is_closing = False
        self._app = tornado.web.Application(handlers, **kwargs)

    def _stop_callback(self):
        if self._is_closing:
            tornado.ioloop.IOLoop.current().stop()

    def addhandler(self, pattern, handler, data=None):
        if data is not None:
            t = (pattern, handler, data)
        else:
            t = (pattern, handler)
        self._app.add_handlers(r'.*', [t])

    def run(self):
        logging.info('starting web.Server')
        self._app.listen(self._port)
        tornado.ioloop.PeriodicCallback(self._stop_callback, 1000).start()
        tornado.ioloop.IOLoop.current().start()
        logging.info('exiting web.Server')

    def stop(self):
        self._is_closing = True

class ServiceHandler(BaseHandler):

    async def get(self, function):
        # Get the function attributes
        attrs = {k: v[0].decode('utf-8')
            for k, v in self.request.query_arguments.items()}
        f = getattr(self.delegate, function)

        # Call the webservice function
        try:
            files = self.request.files
            if files is not None:
                attrs['files'] = self.request.files
            result = await f(**attrs)
        except Exception as e:
            result = {'error': True, 'errmsg': str(e)}

        # Force the serialization of the result
        try:
            sresult = json.dumps(result)
        except TypeError:
            sresult = json.dumps(result.__dict__)
        self.write(sresult)

class WebService:

    def __init__(self, base, server, delegate):
        server.addhandler(r'/{}/(.*)'.format(base), ServiceHandler,
            data={'delegate': delegate})

class Application:
    '''Music server main application.'''

    def __init__(self, configuration):
        self._load_configuration(configuration)
        self._setup_logger()
        self._setup_musicserver()
        self._start_webserver()

    def _load_configuration(self, configuration):
        '''Load the configuration from the json file.'''
        with open(configuration, 'r') as f:
            self._configuration = json.loads(f.read())

    def _setup_logger(self):
        '''Setup the logger.'''
        logging_args = {
            'format': '%(asctime)s: %(levelname)s: %(message)s',
            'datefmt': '%b %d %H:%M:%S'
        }
        try:
            logging_args['filename'] = self._configuration['logfile']
        except KeyError: pass
        try:
            logging_args['level'] = self._configuration['loglevel']
        except KeyError: pass
        logging.basicConfig(**logging_args)

    def _setup_musicserver(self):
        '''Setup the Music Server.'''
        # Get the path for the music files
        songs_path = self._configuration['songspath']
        self._musicserver = MusicServer(songs_path)

    def _start_webserver(self):
        '''Start the web interface.'''
        try:
            port = self._configuration['webserver']['port']
        except KeyError:
            raise Error('undefined port for web server')
        # TODO: remove
        """try:
            datapath = self._configuration['webserver']['datapath']
        except KeyError:
            raise Error('undefined datapath')"""
        self._webserver = WebServer([], port=port)
        self._delegate = WebServiceDelegate(self._musicserver)
        self._service = WebService(
            'musicserver', self._webserver, self._delegate)

    def run(self):
        '''Run the main application.'''
        logging.info('starting')
        self._webserver.run()
        logging.info('exiting')

    def stop(self):
        self._webserver.stop()

class WebServiceDelegate(object):

    def __init__(self, musicserver):
        self._musicserver = musicserver

    async def clear(self):
        '''Remove all songs from the playlist.'''
        self._musicserver.clear()

    """async def devices(self, type):
        return [d.name for d in self._devices.values() if d.type == type]

    async def properties(self, device):
        return self._devices[device].properties()

    async def command(self, device, cmd, **kwargs):
        self._devices[device].command(cmd, **kwargs)"""

############################### Core services #################################

class MusicServer:
    '''MusicServer interface.'''

    def __init__(self, songspath):
        self._player = Player()
        self._playlist = Playlist()

    def clear(self):
        '''Clear all songs in the playlist.'''
        # First, stop the player
        self._player.stop()

        # Then, clear the playlist
        self._playlist.clear()

    def enqueue(self, searchid):
        '''Enqueue a song given its search id.'''
        self._playlist.enqueue(searchid)

    """def delete(self, song):
        '''Delete the given song.'''
        try:
            del self._songs[song]
        except KeyError: pass

    def getCurrentSongStatus(self):
        '''Return the status of the song being played.'''
        return self._playlist.getCurrentSongStatus()

    def getPlaying(self):
        '''Return True if the music server is playing, False if it's Paused.'''
        return self._playing

    def getQueuedSongs(self):
        '''Return all the songs enqueued to be played, including the current
        one.'''
        return self._playlist.getQueuedSongs()

    def getUser(self, cookie):
        '''Return the user logged with the given cookie.'''
        return self._usersmanager.getUser(cookie)

    def getVolume(self):
        '''Return the current volume level.'''
        return self._volume

    def login(self, username, password):
        '''Perform a user login.'''
        self._usersmanager.login(username, password)

    def logout(self, cookie):
        '''Logout the user with the given cookie.'''
        self._usersmanager.logout(cookie)

    def next(self):
        '''Play the next song.'''
        g = iter(self._songs)
        currentsong = next(g)
        del self._songs[currentsong]

    def playpause(self):
        '''Play or Pause the current song.'''
        self._playing = not self._playing
        return self._playing

    async def search(self, query):
        '''Search for a query.'''
        return await self._searchengine.search(query)

    def setUserCookie(self, username, cookie):
        '''Set the cookie for the given user.'''
        self._usersmanager.setCookie(username, cookie)

    def setVolume(self, volume):
        '''Set the playing volume.'''
        self._volume = volume"""

class Player:
    '''Plays songs.'''

    def stop(self):
        '''Stop playing the current song.'''
        pass

class Playlist:
    '''Keeps a queue of songs to play.'''

    def __init__(self):
        self._queue = collections.deque()

    def clear(self):
        '''Remove all songs in the playlist.'''
        self._queue.clear()

############################## Main entry point ###############################

def parse_args():
    parser = argparse.ArgumentParser(
        description='A server to enqueue songs.', prog=__script__)
    parser.add_argument('-c', '--conf', required=True,
        help='the configuration file for the music server')
    parser.add_argument('-d', '--daemonize', action='store_true',
        help='daemonize this process')
    parser.add_argument('-p', '--pidfile', help='the PID file')
    parser.add_argument('--version', action='version',
        version=f'%(prog)s {__version__}')
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_args()
    app = Application(args.conf)
    d = Daemon(app, args.daemonize, args.pidfile)
    with d:
        app.run()

